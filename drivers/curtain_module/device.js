"use strict";

const { ZigBeeDevice } = require("homey-zigbeedriver");
const { Cluster, debug, CLUSTER } = require("zigbee-clusters");
const TuyaWindowCoveringCluster = require("../../lib/TuyaWindowCoveringCluster");
const { mapValueRange } = require('../../lib/util');

Cluster.addCluster(TuyaWindowCoveringCluster);

class curtain_module extends ZigBeeDevice {
    async onNodeInit({ zclNode }) {
        await super.onNodeInit({ zclNode });

        this.printNode();

        this.registerCapability(
            "windowcoverings_set",
            CLUSTER.WINDOW_COVERING,
            {
                reportParser: (value) => {
                    // Validate input
                    if (value < 0 || value > 100) return null;

                    // Refresh timer if needed
                    if (this._reportPercentageDebounce) {
                        this._reportPercentageDebounce.refresh();
                    }

                    // If reports are not generated by set command from Homey update directly
                    if (!this._reportDebounceEnabled) {
                        const reverse = this.getSetting("reverse")
                        return reverse ? mapValueRange(0, 100, 1, 0, value) : mapValueRange(0, 100, 0, 1, value);
                    }

                    // Return value
                    return null;
                },
            }
        );
        await this._configureStateCapability(this.getSetting("has_state"));

        const attrs = await this.zclNode.endpoints[1].clusters.windowCovering
            .readAttributes("calibrationTime", "motorReversal")
            .catch((err) =>
                this.error("Error when reading settings from device", err)
            );

        if (attrs.calibrationTime) {
            await this.setSettings({ movetime: attrs.calibrationTime / 10 });
        }

        if (attrs.motorReversal) {
            this.setSettings({ reverse: attrs.motorReversal === 'On' })
        }

        const moveOpen = this.homey.flow.getActionCard("move_open");
        moveOpen.registerRunListener(async (args, state) => {
            await this.zclNode.endpoints[1].clusters.windowCovering[
                "downClose"
            ]();
        });

        const moveClose = this.homey.flow.getActionCard("move_close");
        moveClose.registerRunListener(async (args, state) => {
            await this.zclNode.endpoints[1].clusters.windowCovering["upOpen"]();
        });
    }

    // When upgrading to node-zigbee-clusters v.2.0.0 this must be adressed:
    // v2.0.0
    // Changed Cluster.readAttributes signature, attributes must now be specified as an array of strings.
    // zclNode.endpoints[1].clusters.windowCovering.readAttributes(['motorReversal', 'ANY OTHER IF NEEDED']);

    async onSettings({ oldSettings, newSettings, changedKeys }) {
        try {
            if (changedKeys.includes("reverse")) {
                const motorReversed = newSettings["reverse"];
                await this.zclNode.endpoints[1].clusters.windowCovering.writeAttributes(
                    { motorReversal: motorReversed ? "On" : "Off" }
                );
            }

            if (changedKeys.includes("calibration_mode")) {
                const calibrationMode = newSettings["calibration_mode"];
                await this.zclNode.endpoints[1].clusters.windowCovering.writeAttributes(
                    { calibrationMode: calibrationMode ? "Start" : "End" }
                );
            }

            if (changedKeys.includes("movetime")) {
                const movetime = newSettings["movetime"];
                await this.zclNode.endpoints[1].clusters.windowCovering.writeAttributes(
                    { calibrationTime: movetime * 10 }
                );
            }

            if (changedKeys.includes("has_state")) {
                await this._configureStateCapability(newSettings["has_state"]);
            }
        } catch (e) {
            this.error("Error during setting change", e);
        }
    }

    onDeleted() {
        this.log("Curtain Module removed");
    }

    async _configureStateCapability(hasState) {
        const key = "windowcoverings_state";

        if (hasState) {
            if (!this.hasCapability(key)) {
                await this.addCapability(key);
            }

            this.registerCapability(key, CLUSTER.WINDOW_COVERING, {
                report: "windowCoverStatus",
                reportParser: (val) => {
                    return {
                        Open: "up",
                        Stop: "idle",
                        Close: "down",
                    }[val];
                },
                reportOpts: {
                    configureAttributeReporting: {
                        minInterval: 0, // No minimum reporting interval
                        maxInterval: 300, // Maximally every ~5 minutes
                        minChange: 1, // Report when value changed by 1
                    },
                },
            });
        } else if (this.hasCapability(key)) {
            await this.removeCapability(key);
        }
    }
}

module.exports = curtain_module;
